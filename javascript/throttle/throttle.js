/**
 * @param {Function} fn
 * @param {number} t
 * @return {Function}
 */
var throttle = function(fn, t) {
    let isThrottled = false;
    let nextArgs = {};
    return function (...args){
        if(isThrottled){
            nextArgs["args"] = args;
        }else{
            fn(...args);
            isThrottled = true;
            setTimeout(helper,t);
        }
        function helper(){
            if(nextArgs["args"]){
                fn(...nextArgs["args"]);
                isThrottled = true;
                nextArgs = {}
                setTimeout(helper,t)
            }else{
                isThrottled = false;
            }
        }
}
};

/**
* const throttled = throttle(console.log, 100);
* throttled("log"); // logged immediately.
* throttled("log"); // logged at t=100ms.
*/


/* OPTIONAL EXAMPLE


var throttle = function(fn, t) {
  let timerId;
  let lastArgs;
  let shouldCall = true;

  function execute() {
    if (shouldCall && lastArgs) {
      fn(...lastArgs);
      lastArgs = null;
      shouldCall = false;
      setTimeout(() => {
        shouldCall = true;
        execute();
      }, t);
    }
  }

  return function(...args) {
    lastArgs = args;
    execute();
  };
};


EXPLANATION

The provided code implements a throttling mechanism for a given function fn with a specified time interval t. The throttled function allows the original function to be called immediately but restricts subsequent calls within the specified time interval.

Let's break down the code:

Variable Declarations:

timerId is declared to track the timeout ID generated by setTimeout.
lastArgs is declared to store the most recent set of arguments passed to the throttled function.
shouldCall is declared to control whether the original function should be called or not.
execute Function:

The execute function is defined to execute the original function and handle the throttling behavior. It performs the following steps:

It checks if shouldCall is true and if there are stored arguments (lastArgs).
If both conditions are met, it calls the original function fn with the stored arguments using the spread operator ...lastArgs.
After the function call, lastArgs is set to null to indicate that the arguments have been processed.
shouldCall is set to false to prevent immediate subsequent calls until the specified time interval has elapsed.
It then uses setTimeout to schedule a callback that sets shouldCall back to true and recursively calls execute after the specified time interval t. This allows the throttled function to be called again.
Return Value:

The throttle function returns an anonymous function that serves as the throttled version of the original function. This returned function takes a variable number of arguments (...args). When called, it assigns the provided arguments to lastArgs and immediately invokes the execute function to trigger the throttling mechanism.

Overall, this code provides a simple implementation of a throttling function that restricts the frequency of function calls based on a specified time interval. It ensures that the original function is called only once within the interval, using the most recent set of arguments provided during that period

*/
